#### 概念

> 基于`顺序存储`的物理结构实现的`线性表`，被称为`顺序表`
>
> 即：将逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中，用存储单元之间的邻接关系来体现数据元素之间的逻辑关系

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210925221352860.png'></img>

---

#### 顺序表的实现

> 写代码应当以用户为导向，让用户用得爽 ！（比如我们封装一系列的基本操作就是为了方便用户使用我们定义的数据结构）</br>
>
> 注意：
>
> 1. 有的编译器会给 int 型变量设置初始值 0，有的编译器则不会
>
> 2. 当涉及表结点的增删，一定要及时更新表长 ！

##### 静态分配方式

- 期望

```c
// 实例化一个顺序表
SeqList list;
```

- 代码实现：定义一种新的数据类型 => 静态顺序表 SeqList

> 1. 用定长数组存放数据元素
>
> 2. 用一个整型数存放表长

```c
#define maxSize 10    // 顺序表的最大容量
typedef struct {
  int data[maxSize];  // ANSI-C 规定，数组定义时长度必须是 「常量」，而不能是 const 修饰的 「只读变量」
  int length;         // C 定义结构体时不允许赋初值，因为定义结构体本质上就是在定义一种新的数据类型
} SqList;
```

- 思考：为什么 maxSize 的定义不放在 SeqList 里面 ？

- 答：

	- 首先明确：SeqList 可以被实例化出很多不同的顺序表对象

	  - SeqList.data 和 SeqList.length 是每个实例化对象所私有的

	  - 而 maxSize 应当是 SeqList 实例化出来的对象们所公有的，`公共变量`应当在数据结构之外单独定义

	- 其次，如果将 maxSize 放在 SeqList 里面，则每实例化出一个顺序表对象，就会多开辟一块内存空间用于存放 maxSize 变量

	  - 这显然浪费内存空间

	  - 且每一个实例化出的顺序表对象的 maxSize 都会有被修改的风险

```c
sizeof(SeqList); // 顺序表所占内存空间的大小 = maxSize * sizeof(int) + sizeof(int)
```

- 期望

```c
// 初始化顺序表（初始化表长，擦洗内存脏数据）
InitList(list);
```

- 代码实现

```cpp
#include <algorithm>

void InitList(SeqList & list) {
    
  list.length = 0;
	
  for (int i = 0; i < maxSize; i ++) {
    list.data[i] = 0;
  }

  // 参数依次为：初始化谁，初始化到哪儿为止，用啥来初始化（https://zh.cppreference.com/w/cpp/algorithm/fill）
  // fill(list.data, list.data + maxSize, 0);

  // 注意：memset 函数不能用于擦洗内存（https://zh.cppreference.com/w/cpp/string/byte/memset）
}
```

- 思考：初始化顺序表的操作可以省略吗 ？

- 答：不要省略

  - 对于顺序表这种数据结构，虽然在我们为其封装基本操作时，可以使用表长 length 控制允许用户访问的最大下标

  - 但前提是用户真的老老实实地只通过我们封装的基本操作来访问数据元素

  - 显然这种前提很难成立，所以不要省略

- 期望

```c
// 在顺序表对象 list 位序为 1 的地方插入数据元素 123
if (InsertList(&list, 1, 123)) {
  cout << "ok" << endl;
} else {
  cout << "error" << endl;
}
```

- 代码实现

```c
typedef enum { false = 0, true } bool;
// 注意：线性表的位序 index 从 1 开始，而数组的下标从 0 开始
bool InsertList(SeqList* list, int index, int elem) {

  // 如果顺序表满，则拒绝插入操作
  if (list->length == maxSize) {
    return false;
  }

  // 顺序表不满，进行位序的合法性判断 [1, list->length + 1]
  if (index < 1 || index > list->length + 1) {
    return false;
  }

  // 数据元素后移
  for (int i = list->length; i >= index; i --) {
    list->data[i] = list->data[i - 1];
  }

  // 数据元素插入
  list->data[index - 1] = elem;

  // 更新 length
  list->length ++;

  return true;

}
```

- InsertList 算法的时间复杂度分析

  - 问题规模：顺序表的表长`list->length`

  - 关注最深层循环语句的执行次数与问题规模之间的关系

    - 最好情况：`O(1)`，新元素插入到表尾，不需要移动元素，循环 0 次

    - 最坏情况：`O(n)`，新元素插入到表头，原有的所有元素都需向后移动，循环 n 次

    - 平均情况：`O(n)`

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926105919982.png'></img>

- 期望

```c
// 按位查找（只是想查找结点就没必要传地址，防止误操作对顺序表造成破坏，传一份 「快照」 即可）
int res = GetItem(list, 1);
```

- 代码实现

```c
// 注意：线性表的位序 index 从 1 开始，而数组的下标从 0 开始
int GetItem(SeqList list, int index) {

  // 位序的合法性判断 [1, list.length]
  if (index < 1 || index > list.length) {
    printf(""您提供的位序不合法"\n");
    return -1;
  }

  return list.data[index - 1];

}
```

- GetItem 算法的时间复杂度分析

  - `O(1)`，没有任何的循环，递归调用等操作

- 期望

```c
// 按值查找
int idx = LocateElem(list, 123);
```

- 代码实现

```c
// 注意：线性表的位序 index 从 1 开始，而数组的下标从 0 开始
int LocateElem(SeqList list, int key) {

  for (int i = 0; i < list.length; i ++) {
    if (list.data[i] == key) {
      // 查到就直接返回位序
      return i + 1;
    }
  }

  // 没查到
  return 0;

}
```

- LocateElem 算法的时间复杂度分析

  - 问题规模：顺序表的表长`list->length`

  - 关注最深层循环语句的执行次数与问题规模之间的关系

    - 最好情况：`O(1)`，目标元素在表头，循环 1 次

    - 最坏情况：`O(n)`，目标元素在表尾，循环 n 次

    - 平均情况：`O(n)`

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926110630217.png'></img>

- 期望

```c
// 根据位序删除数据元素
int elem;
DeleteList(list, 1, elem);
```

- 代码实现

```cpp
// 注意：线性表的位序 index 从 1 开始，而数组的下标从 0 开始
bool DeleteList(SeqList & list, int index, int & elem) {

  // 位序的合法性判断 [1, list.length]
  if (index < 1 || index > list.length) {
    return false;
  }

  // 位序合法，将要被删除的数据元素返回
  elem = list.data[index - 1];

  // 删除指定位序的数据元素
  for (int i = index; i < list.length; i ++) {
    list.data[i - 1] = list.data[i];
  }

  // 更新 length
  list.length --;

  return true;
}
```

- DeleteList 算法的时间复杂度分析

  - 问题规模：顺序表的表长`list->length`

  - 关注最深层循环语句的执行次数与问题规模之间的关系

    - 最好情况：`O(1)`，删除表尾元素，不需要移动其他元素，只需将表长减一即可，循环 0 次

    - 最坏情况：`O(n)`，删除表头元素，需要将后续的 n-1 个元素全都向前移动，然后将表长减一，循环 n-1 次

    - 平均情况：`O(n)`

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926111107368.png'></img>

##### 动态分配方式

>静态分配方式实现的顺序表 => 无法扩容
>
>为了弥补这一缺陷，人们设计出动态分配的方式来实现顺序表
>
>即 => 将顺序表中存储数据的属性由固定长度的静态数组改为指向数组的指针，然后，就可以通过重新申请更大的连续内存空间并改变指针的指向来实现动态扩容的目的
>

- 期望

```c
// 实例化一个顺序表
SeqList L;
```

- 代码实现

```c
typedef struct {
  int* dataPtr; // 指向动态分配的数组
  int curSize;
  int length;
} SqList;
```

- 思考：为什么将 curSize 放在 SeqList 里面 ？

  - 答：因为以动态分配方式实现的顺序表对象自身可以扩容，故 curSize 应被定义为私有属性，放在 SeqList 里面

- 期望

```c
// 初始化顺序表
InitList(&L);
```

- 代码实现

```c
#include <stdio.h>
#include <stdlib.h> // malloc & free

#define defaultSize 10
#define defaultLen 0

SqList* InitList(SqList* list) {
  // 无论如何看见野指针赶紧置 NULL
  list->dataPtr = NULL;

  // 尝试为动态分配的数组申请一片连续的内存空间
  // 如果内存空间分配成功，则 malloc 会返回空间的起始地址（默认为 void *），需要强制转换成和你定义的数据元素的数据类型相对应的指针（不强转的后果参考下图）
  int* tmp = (int*)malloc(defaultSize * sizeof(int));
  if (tmp == NULL) {
    printf("内存空间-申请失败\n");
    return NULL;
  }

  list->dataPtr = tmp;

  // 擦洗内存脏数据
  for (int i = 0; i < defaultSize; i ++) {
    list->dataPtr[i] = 0;
  }

  list->curSize = defaultSize;
  list->length = defaultLen;
  
  return list;
}
```

- 思考：为什么要定义 defaultSize 和 defaultLen ？

	- 答：方便顺序表对象的初始化操作，也让常量值具有更好的可读性

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926104347256.png'></img>

- 期望

```c
// 顺序表动态扩容（以让 maxSize 加 5 为例）
IncreaseSize(&L, 5);
```

- 代码实现

```c
bool IncreaseSize(SqList* list, int growth) {

  // 尝试申请一片更大的连续内存空间
  int newSize = list->curSize + growth;
  int* tmp = (int*)malloc(newSize * sizeof(int));
  if (tmp == NULL) {
    return false;
  }

  // 内存空间申请成功，先将原来的内存空间缓存住（为了最后的数据迁移以及释放原来的内存空间）
  int* oldData = list->dataPtr;

  // 更改指针的指向到更大的新的存储空间，擦洗内存（处理内存脏数据），更新顺序表的最大容量
  list->dataPtr = tmp;
  for (int i = 0; i < newSize; i ++) {
    list->dataPtr[i] = 0;
  }
  list->curSize = newSize;

  // 数据迁移（从原来的内存空间复制到新申请的连续内存空间中，时间开销大）
  for (int i = 0; i < list->length; i ++) {
    list->dataPtr[i] = oldData[i];
  }

  // 释放原来的内存空间
  free(oldData);
  return true;
}
```

#### 顺序表的优缺点

> 基本都是因为静态数组的物理结构

- 优点：

  - 1. 顺序存储，支持随机访问（可在 `O(1)` 时间内找到第 `i` 个数据元素，`data[i-1]`）

  - 2. 数据的存储密度高，因为每个结点只存放数据元素（链表的每个结点还需存放指针）

- 缺点：

  - 1. 内存利用率低，因为要求存储空间连续

  - 2. 改变容量麻烦，时间开销大（静态分配方式实现的顺序表无法改变容量）

  - 3. 增删结点麻烦，需要移动大量元素，时间开销大

#### 注意

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926111949577.png'></img>

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926111834385.png'></img>

#### 总结

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926112901360.png'></img>

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20210926112953281.png'></img>
