> 对于普通双链表，我们无论是从头结点找尾结点 || 从尾结点找头结点；都需要遍历整条链表，时间复杂度为`O(n)`
>
> 但对于循环双链表，我们无论是从头结点找尾结点 || 从尾结点找头结点；时间复杂度都为`O(1)`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010163447287.png"></img>

```c
// 期望：声明并初始化一个带头结点的循环双链表
CDList L;
InitCDList(&L);
```

```c
// 代码实现
/* --------- 定义循环双链表 --------- */
struct NODE {
  int data;
  struct NODE * next;
  struct NODE * prior;
};

typedef struct NODE CDNode;
typedef struct NODE * CDList;
/* --------- 定义循环双链表 --------- */

// 初始化一个带头结点的循环双链表
CDList InitCDList(CDList * list) {
  CDNode * tmp = (CDNode *)malloc(sizeof(CDNode));
  if (tmp == NULL) {
    return NULL;
  }

  tmp->next = tmp;
  tmp->prior = tmp;
  (*list) = tmp;

  return (*list);
}
```

```c
// 判空操作
typedef enum { false = 0, true } bool;
bool isEmpty(CDList list) {
  return (list->next == list);
}
```

```c
// 判尾结点操作
bool isTail(CDList list, CDNode * ptr) {
  if (list == NULL || ptr == NULL) {
    return false;
  }
  return (ptr->next == list);
}
```

#### 在实现基本操作时，相比于普通双链表，循环双链表更方便！

- 这是由于循环双链表中的每一个结点都有 「前驱结点」 `和` 「后继结点」，实现 “插入” 和 “删除” 操作时，就省去了对尾结点的特殊处理（即省去了对 “空指针错误” 的特殊处理）

- 若忘记可自行回顾王道视频～

#### 总结：对于所有的链表问题

> 都需要知道`「空表」`的状态，都需要`「关注对临界情况是否需要特殊处理」`，都需要`「注意增删结点实时更新指针」`，都需要注意`「避免野指针」`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010171213832.png"></img>
