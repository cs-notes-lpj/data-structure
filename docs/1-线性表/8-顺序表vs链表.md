<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211011110049160.png"></img>

#### 逻辑结构

> 都是`线性结构`，都`属于线性表`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211011111430054.png"></img>

#### 存储结构

- 顺序表：
  - 支持随机存取（能立刻找到第 i 个结点的位置） <= (顺序存储 + 各个结点大小相等 + 顺序表的起始地址)
  - 数据存储密度高 <= 各个结点只存放数据元素本身
  - 缺点：
    - 大片连续内存空间分配不方便，内存利用率低
    - 改变容量不方便
    - 插入删除不方便
- 链表：
  - 内存空间易分配，内存利用率高
  - 改变容量方便
  - 插入删除方便
  - 缺点：
    - 不支持随机存取
    - 数据的存储密度相对较低

#### 基本操作

> 创建，销毁，增删改查！

------

- 初始化操作

  - 一个顺序表对象：

    - 需要预分配一片连续空间

    - 若分配空间过小，则之后不方便拓展容量（静态分配方式实现的顺序表的容量无法改变！）

    - 若分配空间过大，则浪费内存资源

  - 一个链表对象：

    - 只需声明一个头指针（还可再创建一个头结点来方便后续的代码实现）

------

- 销毁操作

  - 链表：

    - 利用 free 函数遍历销毁链表中的各个结点

  - 顺序表：

    - `手动` => length=0

    - 对于静态分配方式实现的顺序表，系统会自动回收静态数组内存空间

    - 对于动态分配方式实现的顺序表，`手动` => `L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize); free(L.data);`

注意：

  由 malloc 函数分配的内存空间属于内存中的 「堆区」，堆区的内存空间需要我们手动调用 free 函数进行释放

  即：malloc 和 free 一定成对出现！

------

- 插入/删除

  - 顺序表：

    - 需要将后续结点都后移/前移

    - 最坏/平均时间复杂度都是`O(n)`，时间复杂度主要来自于大量移动结点

  - 链表：

    - 只需修改指针的指向

    - 最坏/平均时间复杂度都是`O(n)`，时间复杂度主要来自于查找目标结点

注意：

  虽然顺序表和链表最坏/平均时间复杂度都是`O(n)`

  但在数据元素本身就很大时，比如一个数据元素就占 1MB，那么查找数据元素的时间开销 << 移动数据元素的时间开销

  即`结合实际情况，链表的效率往往比顺序表高得多`

------

- 查找

  - 链表：

    - 无论如何都只能逐个遍历，时间复杂度为`O(n)`

  - 顺序表：

    - 按位查找：`O(1)` <= 顺序表支持随机存取

    - 按值查找：

      - 数据元素无序：`O(n)`

      - 数据元素有序：`O(log_2^n)` <= 利用折半查找等算法进行优化

`顺序表的查找效率更高`

------

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211011115610817.png"></img>

------

#### 实际应用

- 课堂点名小程序 => 班级人数固定，搜索操作较频繁 => 顺序表！

- 奶茶店叫号小程序 => 顾客人数无法预估，增删操作较多 => 链表！

------

#### 开放式问题的答题思路

- 注意答题逻辑的清晰度！最后给出结论！

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211011120206682.png"></img>