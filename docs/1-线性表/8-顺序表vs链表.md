#### 概览

![image-20211011115610817](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20211011115610817.png)

#### 开放式问题的答题思路

> 注意要逻辑清晰，最后给出结论 ！

![image-20220124170404644](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220124170404644.png)

---

#### 对比：初始化操作

- 一个顺序表对象

  - 需要预分配一片连续空间

  - 若分配空间过小，则之后不方便拓展容量（静态分配方式实现的顺序表就压根儿无法拓容 ！）

  - 若分配空间过大，则浪费内存资源

- 一个链表对象

  - 只需声明一个头指针（还可再创建一个头结点来方便写代码）

---

#### 对比：销毁操作

- 链表：使用`free`函数，遍历销毁链表中的各个结点

- 顺序表：

  - 首先：无论是静态分配方式实现还是动态分配方式实现，都需要我们手动将顺序表的`length`重置为`0`

  - 对于静态分配方式实现的顺序表，系统会自动回收静态数组的内存空间

  - 对于动态分配方式实现的顺序表

  ```c
  ElemType* ptr = L.data;

  L.data = (ElemType*)malloc(InitSize * sizeof(ElemType));

  free(ptr);
  ```

---

#### 对比：查找操作

- 链表：只能逐个遍历，时间复杂度为`O(n)`

- 顺序表：

  - 按位查找：`O(1)`，因为顺序表支持随机访问呀

  - 按值查找：

    - 数据元素无序：`O(n)`

    - 数据元素有序，则可利用折半查找算法进行优化：`O(log_2^n)`

> 显然顺序表的查找效率更高 ！

#### 对比：插入/删除

- 顺序表：需要大量移动结点，平均/最坏时间复杂度都是`O(n)`

- 链表：只需修改指针的指向，但由于链表不支持随机访问（需要挨个儿查找目标结点），所以平均/最坏时间复杂度也都是`O(n)`

#### 实际应用

- 课堂点名小程序 => 班级人数固定，搜索操作较频繁 => 顺序表 ！

- 奶茶店叫号小程序 => 顾客人数无法预估，增删操作较多 => 链表 ！

#### 思考

虽然顺序表和链表最坏/平均时间复杂度都是`O(n)`

但在数据元素本身就很大时，比如一个数据元素就占 1MB，那么移动数据元素的时间开销 >> 查找数据元素的时间开销

所以，结合实际情况，顺序表和链表相比，链表的效率往往较高

![image-20220124173222932](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220124173222932.png)

（第一章：完）
