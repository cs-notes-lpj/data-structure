#### 回顾：啥叫链表？

>
> 链表 => 使用`链式存储`的物理结构实现的`线性表`
>
> 定义解析 => `逻辑上相邻`的数据元素存储在`物理位置上离散`的存储单元中，数据元素之间的关系由`指针`来体现
>

#### 静态链表的特点和优缺点

- 特点：
  - `静态链表是用数组的方式实现的链表，分配了一整片连续的内存空间，各个结点集中安置`（而单链表的结点在内存中星罗棋布，散落天涯）

- 优点：
  - 和其他链表的优点之一类似，静态链表增删结点方便，只需修改「游标」，不需移动大量结点
- 缺点：
  - 要求存储空间连续导致内存利用率低（其他链表内存利用率高）
  - 不支持随机访问（是个链表都不支持）
  - `不能改容量`（其他链表可以很方便地改变容量）

> 注意：静态链表虽然是一整片连续的内存空间，但它仍然符合链表的定义，即 「`逻辑上相邻`的数据元素存储在`物理位置上离散`的存储单元中，数据元素之间的关系由`指针`来体现」

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211011231523864.png"></img>

#### 静态链表的适用场景？

1. 不支持指针的低级语言
2. 数据元素数量固定不变的场景，还想插入删除方便（如操作系统的文件分配表 FAT）

#### 如何定义一个静态链表？

```c
// 首先将 「静态链表的结点」 这种新的构造数据类型定义出来
struct Node {
  ElemType data;	// 存储数据元素
  int next;				// 存储游标，即下一个结点的数组下标
}

#define maxSize 10 // 定义静态链表的最大长度（静态链表无法改变容量）

// 声明一个静态链表
struct Node slist[maxSize];
```

- 但 `struct Node slist[maxSize];` 只能看出来我们声明了一个存放结点的数组，看不出我们是在声明一个静态链表
- 为了表达这层意思，我们使用 `typedef` 给长度为 maxSize 的 Node 型数组设置别名

```c
typedef struct Node SLinkList[maxSize];

// 如此一来，我们声明一个静态链表，就只需
SLinkList slist;
```

#### 简述基本操作的实现？

##### 初始化

> 将头结点的 next 设置为 -1
>
> 将数组除头结点外的其余结点的 next 都设置为特殊值 -2 表示结点为「空」

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211011232924698.png"></img>

##### 查找

> 从头结点出发，挨个向后遍历结点；时间复杂度为`O(n)`

##### 按位序插入

> 和单链表的按位序插入「如出一辙」；注意区分好「数组下标」、「位序」、「游标/指针」

1. 找到一个空的结点，存入数据元素
2. 从头结点出发，找到位序为 i-1 的结点
3. 修改新结点的 next
4. 修改位序 i-1 结点的 next

##### 那么删除某个结点

1. 从头结点出发找到其前驱结点
2. 修改前驱结点的游标
3. 将被删除结点的 next 重新设置回特殊值 -2，表示结点为「空」

#### 链表相关的注意事项

> 都需要知道`「空表」`的状态，都需要`「关注对临界情况是否需要特殊处理」`，都需要`「注意增删结点实时更新指针」`，都需要注意`「避免野指针」`
