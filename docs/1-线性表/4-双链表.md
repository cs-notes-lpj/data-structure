> 单链表无法逆向检索，为了弥补这一缺陷，人们提出了双链表

> 而由于双链表支持逆向检索，所以（指定结点前插操作 <=> 逆向检索 + 指定结点后插）

#### 双链表（带头结点版）

![](https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20220121214920178.png)

> 双链表的结点比单链表的结点多一个指向其前驱的指针，故相比于单链表，双链表的数据存储密度更低

#### 双链表的定义（带头结点版）

```c
/* --------- 定义双链表 --------- */
struct NODE {
  ElemType data;
  struct NODE * next;
  struct NODE * prior;
}

typedef struct NODE DNode;
typedef struct NODE * DLinkList;
/* --------- 定义双链表 --------- */
```

#### 双链表的初始化（带头结点版）

```c
// 期望
DLinkList L;
if (InitDLinkList(&L)) {
  printf("恭喜，你成功初始化了一个带头结点的空的双链表\n");
}
```

```c
#include <stdlib.h>
typedef enum { false = 0, true } bool;

// 初始化双链表
bool InitDLinkList(DLinkList* list) {

  // 尝试为头结点申请内存空间
  DNode* headNode = (DNode *)malloc(sizeof(DNode));
  if (headNode == NULL) {
    return false;
  }

  (*list) = headNode;
  headNode->next = NULL;
  headNode->prior = NULL;
  return true;
}
```

#### 双链表判空（带头结点版）

```c
#include <stdio.h>
typedef enum { false = 0, true } bool;

bool isEmpty(DLinkList list) {
  if (list == NULL) {
    printf("你传进来的是个 NULL 而并非一个带头结点的双链表，已取消本次判空操作\n");
    return true;
  }
  return (list->next == NULL);
}
```

#### 指定结点后插（带头结点版）

```c
bool InsertNextNode(DNode* destPtr, int data) {

  if (destPtr == NULL) {
    return false;
  }

  // 构造新结点
  DNode* newNode = (DNode*)malloc(sizeof(DNode));
  if (newNode == NULL) {
    return false;
  }
  newNode->data = data;

  // 指定结点后插
  newNode->next = destPtr->next;
  if (destPtr->next != NULL) { // 注意表尾插入
    destPtr->next->prior = newNode;
  }
  destPtr->next = newNode;
  newNode->prior = destPtr;
  return true;
}
```

#### 遍历输出双链表（带头结点版）

```c
// 遍历输出双链表
void printDLinkList(DLinkList list) {
  if (list == NULL) {
    return;
  }

  DNode * ptr = list->next;

  while (ptr != NULL) {
    printf("%d ", ptr->data);
    ptr = ptr->next;
  }

  printf("\n");
  return;
}
```

#### 双链表指定结点删除（带头结点）

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/deleteDNode.png"></img>

```c
// 指定结点删除（等价于删其前驱的后继）
bool DeleteNode(DNode * ptr) {
  if (ptr == NULL) {
    return false;
  }

  DNode * priorPtr = ptr->prior;

  if (priorPtr == NULL) {
    printf("不允许删除双链表的头结点，已取消本次删除结点的操作\n");
    return false;
  }

  priorPtr->next = ptr->next;
  if (ptr->next != NULL) {
    ptr->next->prior = priorPtr;
  }
  free(ptr);

  return true;

}
```

#### 销毁双链表（带头结点）

```c
// 销毁带头结点的双链表
if (DestoryDLinkList(&L)) {
  printf("链表销毁成功\n");
};
printDLinkList(L);
```

```c
// 代码实现
bool DestoryDLinkList(DLinkList * list) {
  if ((*list) == NULL) {
    return false;
  }

  // 得保证传进来的指针指向头结点，才能将双链表完全销毁
  if ((*list)->prior != NULL) {
    return false;
  }

  // 每次都是销毁头结点的后继结点
  while ((*list)->next != NULL) {
    DeleteNode((*list)->next);
  }

  // 销毁头结点
  free(*list);
  (*list) = NULL; // 一定要做这一步！避免因 free 造成的野指针

  return true;

}
```

#### 双链表的遍历（带头结点）

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010122637554.png"></img>
