> 所有的新方案都是为了解决老方案的缺点

#### 单链表的缺点

- 无法逆向检索，有时候使用不太方便

#### 双链表（带头结点）

- 支持逆向检索

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010090536054.png"></img>

#### 双链表的定义、声明、初始化（带头结点）

```c
/* --------- 定义双链表 --------- */
struct NODE {
  ElemType data;
  struct NODE * next;
  struct NODE * prior; // 每个结点比单链表多增加了一个指向其前驱结点的指针，故双链表的数据存储密度比单链表 「低」～
}

typedef struct NODE DNode;
typedef struct NODE * DLinkList;
/* --------- 定义双链表 --------- */
```

```c
// 期望
DLinkList L;
if (InitDLinkList(&L)) {
  printf("恭喜，你声明并初始化了一个带头结点的空的双链表\n");
}

// 代码实现：初始化双链表（带头结点）
#include <stdlib.h>
typedef enum { false = 0, true } bool;
bool InitDLinkList(DLinkList * list) {
  DNode * headNode = (DNode *)malloc(sizeof(DNode));
  if (headNode == NULL) {
    return false;
  }

  // 头结点的 prior 和 next 都得初始化指向 NULL
  headNode->next = NULL;
  headNode->prior = NULL;

  (*list) = headNode;
  return true;

}
```

#### 双链表判空（带头结点）

```c
/** 判断带头结点的双链表是否为空
 * 返回 true：说明你传进来的带头结点的双链表为 「空」
 * 返回 false：说明你传进来的带头结点的双链表为 「不空」 或你传进来的就不是个带头结点的双链表
*/
bool isEmpty(DLinkList list) {
  if (list == NULL) {
    printf("你传进来的就不是个带头结点的双链表，你传进来的是个 NULL，已取消本次判空操作\n");
    return false;
  }
  return (list->next == NULL);
}
```

#### 双链表指定结点后插（带头结点）

```c
/** 指定结点的后插操作
 * destPtr  被插结点，将在该结点后插入新结点
 * data     新结点中将存放的数据元素
*/
bool InsertNextNode(DNode * destPtr, int data) {
  if (destPtr == NULL) {
    return false;
  }

  DNode * newNode = (DNode *)malloc(sizeof(DNode));
  if (newNode == NULL) {
    return false;
  }
  newNode->data = data;

  newNode->next = destPtr->next;
  if (destPtr->next != NULL) { // 注意表尾插入
    destPtr->next->prior = newNode;
  }
  destPtr->next = newNode;
  newNode->prior = destPtr;

  return true;

}
```

> 注意：由于双链表支持逆向检索，所以（前插 == 逆向检索 + 后插）！

#### 遍历输出双链表（带头结点）

```c
// 遍历输出双链表
void printDLinkList(DLinkList list) {
  if (list == NULL) {
    return;
  }

  DNode * ptr = list->next;

  while (ptr != NULL) {
    printf("%d ", ptr->data);
    ptr = ptr->next;
  }

  printf("\n");
  return;
}
```

#### 双链表指定结点删除（带头结点）

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/deleteDNode.png"></img>

```c
// 指定结点删除（等价于删其前驱的后继）
bool DeleteNode(DNode * ptr) {
  if (ptr == NULL) {
    return false;
  }

  DNode * priorPtr = ptr->prior;

  if (priorPtr == NULL) {
    printf("不允许删除双链表的头结点，已取消本次删除结点的操作\n");
    return false;
  }

  priorPtr->next = ptr->next;
  if (ptr->next != NULL) {
    ptr->next->prior = priorPtr;
  }
  free(ptr);

  return true;

}
```

#### 销毁双链表（带头结点）

```c
// 销毁带头结点的双链表
if (DestoryDLinkList(&L)) {
  printf("链表销毁成功\n");
};
printDLinkList(L);
```

```c
// 代码实现
bool DestoryDLinkList(DLinkList * list) {
  if ((*list) == NULL) {
    return false;
  }

  // 得保证传进来的指针指向头结点，才能将双链表完全销毁
  if ((*list)->prior != NULL) {
    return false;
  }

  // 每次都是销毁头结点的后继结点
  while ((*list)->next != NULL) {
    DeleteNode((*list)->next);
  }

  // 销毁头结点
  free(*list);
  (*list) = NULL; // 一定要做这一步！避免因 free 造成的野指针

  return true;

}
```

#### 双链表的遍历（带头结点）

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010122637554.png"></img>
