## 单链表-封装基本操作

> 封装基本操作的目的
>
> 1. 方便用户使用我们定义的数据结构
> 2. 方便开发者对代码进行复用，使代码高内聚低耦合、逻辑清晰易维护

---

- 插入
  - 按位序插入
  - 指定结点 「后插」 或 「前插」，Tips: 前插 <=> 后插 + 交换数据
- 删除
  - 按位序删除
  - 指定结点删除
- 查找
  - 按位序查找
  - 按值查找

---

#### 按位序插入

##### 有头结点

```c
#include <stdlib.h>                     // malloc & free
typedef enum { false = 0, true } bool;  // C 无 bool，故模拟

// 函数返回值可以是 bool，也可以是链表的头指针；主要看用户想怎么用
bool ListInsert(LinkList* L, int idx, int elem) {

  // 位序的 「左合法性判断」
  if (idx < 1) {
    return false;
  }

  // 从前向后遍历寻找要插入位序的前一位（回忆：存放了数据的结点才有位序，位序最小为 1，但可将头结点看成是位序为 0）
  int i = 0;
  LNode* tmp = *L;
  while (i + 1 < idx) {
    tmp = tmp->next;
    if ( tmp == NULL ) {
      return false;
    }
    i ++;
  }

  // 找到，则尝试为新结点申请内存空间
  LNode* newNode = (LNode*)malloc(sizeof(LNode));
  if (newNode == NULL) {
    return false;
  }

  // 插入新结点
  newNode->data = elem;
  newNode->next = tmp->next;
  tmp->next = newNode;
  return true;
}
```

##### 无头结点

```c
#include <stdlib.h>
typedef enum { false = 0, true } bool;

bool ListInsert(LinkList* list, int idx, int elem) {
  
  // 位序的 「左合法性判断」
  if (idx < 1) {
    return false;
  }

  // 要插入的位序为 1，因无前驱，故需单独处理
  if (idx == 1) {

    // 尝试为新结点申请内存空间
    LNode* node = (LNode *)malloc(sizeof(LNode));
    if (node == NULL) {
      return false;
    }

    // 插入新结点
    node->data = elem;
    node->next = *list;
    *list = node; // 改变头指针的指向
    return true;
  }

  // 要插入的位序大于 1，则从前向后遍历寻找要插入位序的前驱
  int i = 1;
  LNode* ptr = *list;
  while (i + 1 < idx) {
    ptr = ptr->next;
    if (ptr == NULL) {
      return false;
    }
  }

  // 尝试为新结点申请内存空间
  LNode* newNode = (LNode*)malloc(sizeof(LNode));
  if (newNode == NULL) {
    return false;
  }

  // 插入新结点
  newNode->data = elem;
  newNode->next = ptr->next;
  ptr->next = newNode;
  return true;
}
```

##### 有无头结点对比

- 有头结点 => 对于任意合法位序的插入，代码的处理逻辑都统一 && 头指针的指向不变（始终指向头结点）

- 无头结点 => 当插入位序为 1

  - 需用单独的代码逻辑处理
  
  - 需改变头指针的指向（指向新结点）

##### 算法的时间复杂度分析

- 最好时间复杂度：`O(1)`，插入位序为 1，不涉及任何循环或递归

- 最坏时间复杂度：`O(n)`，插入位序刚好为表尾结点的下一个位置

- 平均时间复杂度：`O(n)`，同之前的分析方法，用加权平均值求时间复杂度，最终结果为 n 的一次多项式

#### 指定结点后插

> 可复用于按位序插入的后半段

> 注意：
>
> 当给出一个指向单链表中某结点的指针，我们就可以访问包含该结点在内的其后所有结点
>
> 而无法访问除该结点外前面可能存在的结点，除非拿到单链表的头指针

```c
#include <stdlib.h>
typedef enum { false = 0, true } bool;

bool InsertNextNode(LNode* ptr, int elem) {

  // 指针合法性判断
  if (ptr == NULL) {
    printf("未指定任何结点，取消插入...\n");
    return false;
  }

  // 尝试为新结点申请内存空间
  LNode* tmp = (LNode*)malloc(sizeof(LNode));
  if (tmp == NULL) {
    return false;
  }

  // 插入新结点
  tmp->data = elem;
  tmp->next = ptr->next;
  ptr->next = tmp;
  return true;
}
```

##### 时间复杂度

> O(1)，因为不涉及任何循环或递归

#### 指定结点前插（无头结点版）

> 指定结点前插 <=> 指定结点后插 + 交换数据

```c
#include <stdlib.h>
typedef enum { false = 0, true } bool;

bool InsertPriorNode(LNode* ptr , int elem) {

  // 指针合法性判断
  if (ptr == NULL) {
    printf("未指定任何结点，取消前插...\n");
    return false;
  }

  // 尝试为新结点申请内存空间
  LNode* newNode = (LNode*)malloc(sizeof(LNode));
  if (newNode == NULL) {
    return false;
  }
  
  // 指定结点后插
  newNode->next = ptr->next;
  ptr->next = newNode;

  // 交换数据
  int tmpData = ptr->data;
  ptr->data = elem;
  newNode->data = tmpData;

  return true;
}
```

##### 时间复杂度

> O(1)，因为不涉及任何循环或递归

#### 按位序删除

##### 有头结点

```c
#include <stdlib.h>
typedef enum { false = 0, true } bool;

// 参数 res 用于将被删结点中的数据带回主调函数上下文
bool ListDelete(LinkList* list, int idx, int* res) {

  if (idx < 1) {
    printf("位序 「左」 非法，取消本次删除...\n");
    return false;
  }

  // 从头结点开始向后遍历寻找要删除结点的前驱（将头结点看成位序 0）
  int index = 0;
  LNode* ptr = *list;
  while (index + 1 < idx) {
    ptr = ptr->next;
    if (ptr == NULL) {
      printf("位序 「右」 非法，取消本次删除...\n");
      return false;
    }
    index ++;
  }

  if (ptr->next == NULL) {
    printf("要删除位序的前驱是尾结点，取消本次删除...\n");
    return false;
  }

  *res = ptr->next->data;         // 数据带回
  LNode* deletedNode = ptr->next; // 缓存
  ptr->next = deletedNode->next;  // 调指向
  free(deletedNode);              // 释结点
  return true;
}
```

##### 无头结点

- 按位序删结点，咋着按位序删 ？先找前驱 ！可是位序为 1 的结点无前驱，故需单独处理

##### 时间复杂度分析

- 最好时间复杂度：`O(1)`，删除位序为 1 的结点，不涉及任何循环或递归

- 最坏时间复杂度：`O(n)`，要删除的位序对应的是表尾元素

- 平均时间复杂度：`O(n)`，同之前的分析方法，用加权平均值求时间复杂度，最终结果为 n 的一次多项式

#### 指定结点删除

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211001114159457.png"></img>

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211001114258201.png"></img>

```c
bool DeleteNode(LNode * ptr, int * res) {

  if (ptr == NULL) {
    printf("指针指向 NULL，已取消本次删结点操作...");
    return false;
  }

  LNode * tmpPtr = ptr->next; // 缓存后继
  
  // 本函数的局限性
  if (tmpPtr == NULL) {
    printf("指针指向尾结点，因尾结点无后继结点，故本方法不可用，已取消本次删结点操作...\n");
    return false;
  }

  ptr->next = ptr->next->next;// 调整指针指向，构造出逻辑结构

  (*res) = ptr->data;         // 带回数据

  ptr->data = tmpPtr->data;   // 重排数据

  free(tmpPtr);               // 释放内存

  return true;
}
```

#### 查找（此处只探讨有头结点）

> 时间复杂度：平均 O(n); 最坏 O(n); 最好 O(1);

##### 按位序查找

> `按位查找`这一基本操作可以很好地被`复用`于`按位插入`和`按位删除`基本操作的封装中

```c
/**
 * {LinkList} list  传入一个有头结点的单链表的「镜像」
 * {int}      idx   要查找结点的位序
 */
LNode * GetElem(LinkList list, int idx) {
  if (idx < 1) {
    printf("位序 「左」 非法，取消本次按位查找...\n");
    return NULL;
  }

  // 从位序 1 的结点开始向后遍历寻找位序为 idx 的结点
  LNode * ptr = list->next;
  int index = 1;

  // 指针每向后移动一位，都应判断是否出界，出界则说明 「位序右非法」，非法则返回
  while (index < idx) {
    ptr = ptr->next;
    index ++;

    if (ptr == NULL) {
      printf("位序 「右」 非法，取消本次按位查找...\n");
      return NULL;
    }
  }

  return ptr;

}
```

##### 按数据域查找

> 注意：判断构造数据类型的数据元素之间的关系，不能用简单的等或不等号，而应封装一个加强版的判等函数来使用 ！

```c
/** 按值查找结点
 * {LinkList} list  传入一个有头结点的单链表的「镜像」
 * {int}      data  要查找结点中存放的数据
 */
LNode * GetElemByData(LinkList list, int data) {

  // 链表判空（带头结点）
  LNode * ptr = list->next;
  if (list == NULL) {
    printf("你传进来的是个带头结点的空链表，取消本次按值查找...\n");
  }

  // 从位序 1 的结点逐个向后遍历查找值对应的结点

  while (ptr->data != data) { // 注意：判断构造数据类型的数据元素之间的关系，不能用简单的等或不等号，而应封装一个加强版的判等函数来使用 ！
    ptr = ptr->next;

    if (ptr == NULL) {
      printf("按值查找结点没找到...\n");
      return NULL;
    }
  }

  return ptr;

}
```

#### 求表长（此处只探讨有头结点）

>
> 头结点不存数据，不算入表长
>
> 时间复杂度：O(n)
>

```c
int Length(LinkList list) {
  if (list->next == NULL) {
    return 0;
  }

  int len = 0;
  for (LNode * ptr = list->next; ptr != NULL; ptr = ptr->next) {
    len++;
  }
  return len;
}
```

#### 建立单链表

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211001174311582.png" style="float: left;"></img>

##### 尾插法

- 一般思路：

```c
初始化一个单链表

while 循环 {
  
  每次取一个数据元素 elem;
  
  将数据元素插入到单链表尾结点的后面;
  
}
```

- 时间复杂度分析：`每插入一个新结点都是从头开始向后遍历寻找尾结点的`，所以时间复杂度为 0 + 1 + 2 + … + (n - 1) = `O(n^2)`

- 优化思路：`设置一个实时更新的表尾指针`

```c
初始化一个单链表，设置并初始化表尾指针 LNode * tail

while 循环 {
  
  每次取一个数据元素 elem;
  
  将数据元素插入到单链表尾结点的后面; // 可使用封装好的指定结点后插操作
  
  实时更新表尾指针的指向;
  
}
```

- 时间复杂度分析：假设数据规模为 n，每插入一个新结点都不涉及任何循环和递归，故时间复杂度为 `O(n)`

##### 头插法

> 即，每创建一个新结点，都将其插入到头结点的后面（重要应用：链表的逆序）

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211001161631045.png" style="float: left;"></img>

- 时间复杂度分析：假设数据规模为 n，每插入一个新结点都不涉及任何循环和递归，故时间复杂度为 `O(n)`

#### 练习 - 声明，初始化，建立一个带头结点的单链表，将其原地逆序

- [代码地址](https://github.com/Brannua/ds_algorithm/blob/master/1_linearList/LinkedList-single-withHead-reverse.c)

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/reverselist.jpg" style="float: left">
