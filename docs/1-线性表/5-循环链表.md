#### 循环单链表

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010161419082.png"></img>

```c
// 声明并初始化一个带头结点的空的循环单链表
LinkList L ;
InitList(&L);
```

```c
struct NODE {
  int data;
  struct NODE * next;
};
typedef struct NODE LNode;
typedef struct NODE * LinkList;

LinkList InitList(LinkList * list) {
  LNode * tmp = (LNode *)malloc(sizeof(LNode));
  if (tmp == NULL) {
		return NULL;
  }
  
  tmp->next = tmp; // 循环单链表和普通单链表初始化的区别就在此
  (*list) = tmp;
  
  return (*list);
}
```

```c
// 循环单链表判空
typedef enum { false = 0, true } bool;
bool isEmpty(CLinkList list) {
  return (list->next == list);
}
```

````c
// 判断指针指向的是否是循环单链表的表尾结点
bool isTail(CLinkList L, CLNode * ptr) {
  if (L == NULL || ptr == NULL) {
    return false;
  }

  return (ptr->next == L);
}
````

> 很多时候，我们对链表的操作都是在 「头部」 或 「尾部」
>
> 若使用普通的单链表：根据头指针找到尾结点只能循环遍历，时间复杂度为`O(n)`
>
> `若使用循环单链表：我们可以让头指针就指向尾结点`，这样，无论我们相对尾结点操作还是头结点操作，都只需要`O(1)`的时间复杂度就可定位到我们要操作的结点
>
> `涉及对结点的增删，就一定要关注相关指针的指向是否需要更新！`

#### 循环双链表

> 对于普通双链表，我们无论是从头结点找尾结点 || 从尾结点找头结点；都需要遍历整条链表，时间复杂度为`O(n)`
>
> 但对于循环双链表，我们无论是从头结点找尾结点 || 从尾结点找头结点；时间复杂度都为`O(1)`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010163447287.png"></img>

```c
// 期望：声明并初始化一个带头结点的循环双链表
CDList L;
InitCDList(&L);
```

```c
// 代码实现
/* --------- 定义循环双链表 --------- */
struct NODE {
  int data;
  struct NODE * next;
  struct NODE * prior;
};

typedef struct NODE CDNode;
typedef struct NODE * CDList;
/* --------- 定义循环双链表 --------- */

// 初始化一个带头结点的循环双链表
CDList InitCDList(CDList * list) {
  CDNode * tmp = (CDNode *)malloc(sizeof(CDNode));
  if (tmp == NULL) {
    return NULL;
  }

  tmp->next = tmp;
  tmp->prior = tmp;
  (*list) = tmp;

  return (*list);
}
```

```c
// 判空操作
typedef enum { false = 0, true } bool;
bool isEmpty(CDList list) {
  return (list->next == list);
}
```

```c
// 判尾结点操作
bool isTail(CDList list, CDNode * ptr) {
  if (list == NULL || ptr == NULL) {
    return false;
  }
  return (ptr->next == list);
}
```

#### 在实现基本操作时，相比于普通双链表，循环双链表更方便！

- 这是由于循环双链表中的每一个结点都有 「前驱结点」 `和` 「后继结点」，实现 “插入” 和 “删除” 操作时，就省去了对尾结点的特殊处理（即省去了对 “空指针错误” 的特殊处理）

- 若忘记可自行回顾王道视频～

#### 总结一下：对于所有的链表问题

> 都需要知道`「空表」`的状态，都需要`「关注对临界情况是否需要特殊处理」`，都需要`「注意增删结点实时更新指针」`，都需要注意`「避免野指针」`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211010171213832.png"></img>
