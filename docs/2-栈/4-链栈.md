> 用 「链式存储」 的物理结构实现的栈
>
> 单链表 + 只允许在一端插入/删除 => 链栈
>

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211012214459040.png"></img>

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211012214306452.png"></img>

#### 「无头结点」的链栈实现（推荐）

```c
/* --- 定义数据类型：链栈的结点 --- */
struct NODE {
  ElemType data;
  struct NODE * next;
};

typedef struct NODE LSNode;
typedef struct NODE * LinkStack;
/* --- 定义数据类型：链栈的结点 --- */
```

```c
typedef enum { false = 0, true } bool;
bool Push(LinkStack * s, int elem) {
  LSNode * tmp = (LSNode *)malloc(sizeof(LSNode)); // 看见 malloc 要敏感，记得调用 free 释放回收内存
  if (tmp == NULL) {
    return false;
  }

  tmp->data = elem;
  tmp->next = *s;
  (*s) = tmp;
  return true;

}
```

```c
void PrintLinkStack(LinkStack s) {
  if (s == NULL) {
    return;
  }

  LSNode * ptr = s;
  while (ptr != NULL) {
    printf("%d ", ptr->data);
    ptr = ptr->next;
  }
  printf("\n");
  return;
}
```

```c
bool Pop(LinkStack * s, int * res) {
  // 栈空则拒绝出栈
  if ((*s) == NULL) {
    return false;
  }

  LSNode * tmp = (*s); // 缓存待出栈结点

  /* --- 出栈 --- */
  (*s) = (*s)->next;
  (*res) = tmp->data;
  free(tmp);
  /* --- 出栈 --- */

  return true;

}
```

```c
// 读栈顶（z）
bool GetTop(LinkStack s, int * res) {
  // 栈空，则拒绝读栈
  if (s == NULL) {
    return false;
  }

  (*res) = s->data;
  return true;
}
```
