
> 1. 考试使用 「顺序栈」 说明算法即可（实际开发中大多使用链栈~）
> 2. 考试可直接使用基本操作，但需对基本操作进行简要说明（写注释）！

- 思路：依次扫描所有字符，由于最后出现的左括号最先被匹配，所以遇到左括号则入栈，遇到右括号则弹出栈顶元素检查是否匹配

- 匹配失败的情况：
  - 1. 左括号单身
  - 2. 右括号单身
  - 3. 左右括号不匹配

#### 算法流程图

> Created by processon.

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013120349001.png"></img>

#### 期望

```c
char arr1[] = {'(', '(', '(', '(', ')', ')', ')', ')'}; // 匹配成功
char arr2[] = {'(', '(', '(', ')', ')', '(', ')', ')'}; // 匹配成功
char arr3[] = {'{', '(', '(', ')', ')', '[', ']', '}'}; // 匹配成功
char arr4[] = {'{', '(', '(', ')', ']', '[', ']', '}'};     // 匹配失败
char arr5[] = {'{', '(', '(', ')', ')', '}', ']', '(', ')'};// 右括号单身
char arr6[] = {'{', '{', '(', '(', ')', ')', '[', ']', '}'};// 左括号单身
```

```c
/**
 * 首先实现两个工具函数
 */
typedef enum { false = 0, true } bool;

// 判断是否为左括号
bool isLeftBrackets(char c) {
  if (c == '(' || c == '[' || c == '{') {
    return true;
  }
  return false;
}

// 判断两个括号是否匹配成对儿
bool isMatch(char a, char b) {
  if (a == '(' && b == ')') {
    return true;
  }
  if (a == ')' && b == '(') {
    return true;
  }
  if (a == '[' && b == ']') {
    return true;
  }
  if (a == ']' && b == '[') {
    return true;
  }
  if (a == '{' && b == '}') {
    return true;
  }
  if (a == '}' && b == '{') {
    return true;
  }
  return false;
}
```

#### 用原生数据结构实现

```c
bool matchBrackets(char arr[], int len) {

  // 栈用于：一边扫描，一边将左括号压入栈
  char stack[len]; int top = -1;

  // 开始扫描
  for (int i = 0; i < len; i ++) {
    if (isLeftBrackets(arr[i])) { // 是左括号，则入栈
      stack[top+1] = arr[i];
      top = top + 1;
      continue;
    } else { // 是右括号，则尝试配对
      if (top == -1) {	// 栈空
        printf("匹配失败，右括号单身\n");
        return false;
      } else {			// 栈不空，则进行配对
        
        if (isMatch(stack[top], arr[i])) {
          top = top - 1;	// 记得弹栈~
          continue;			// 然后继续扫描下一个括号
        } else {
          printf("匹配失败，配对失败\n");
          return false;
        }

      }
    }
  }

  // 扫描结束，栈空吗
  if (top == -1) {
    return true;
  } else {
    printf("匹配失败，左括号单身\n");
    return false;
  }
}
```

#### 用「顺序栈」实现

```c
bool matchBrackets(char arr[], int len) {

  SeqStack s; InitSeqStack(&s);

  // 开始扫描
  for (int i = 0; i < len; i ++) {
    if (isLeftBrackets(arr[i])) { // 是左括号，则入栈
      Push(&s, arr[i]);
      continue;
    } else {					  // 是右括号，则尝试配对
      if (isSeqStackEmpty(s)) {
        printf("匹配失败，右括号单身\n");
        return false;
      } else {

        int oldTop; Pop(&s, &oldTop);
        if (isMatch(oldTop, arr[i])) {
          continue;
        } else {
          printf("匹配失败，配对失败\n");
          return false;
        }

      }
    }
  }

  // 扫描结束，栈空吗
  if (isSeqStackEmpty(s)) {
    return true;
  } else {
    printf("匹配失败，左括号单身\n");
    return false;
  }

}
```
