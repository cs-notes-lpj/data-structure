> 用 「顺序存储」 的物理结构实现的栈
>
> 缺点：`栈的大小无法改变` <= 静态数组存储数据元素
>
> 注意：任何使用顺序栈实现的算法，都应考虑到可能会栈溢出。优化方式如使用链栈~
>
> 考试注意审题：看清栈顶指针到底初始化指向 「-1」 还是 「0」！

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211012210812218.png"></img>

```c
// 我们期望这么声明一个顺序栈（分配内存空间）
SeqStack s;
```

```c
// 代码实现
#define maxZize 10		 // 定义 「顺序栈容量」
typedef struct {
  ElemType data[maxZize]; // 存放 「顺序栈的数据元素」
  int top;				  // 「顺序栈的栈顶指针」，指向栈顶元素，形式为数组下标
} SeqStack;

printf("%d\n", sizeof(SeqStack)); // maxSize * sizeof(ElemType) + sizeof(int)
```

```c
// 我们期望这么对顺序栈进行初始化
InitStack(&s);
```

```c
// 代码实现
typedef enum { false = 0, true } bool;
bool InitStack(SeqStack * s) {
  // 初始化栈顶指针（考试注意审题：看题目说明的栈顶指针到底是初始化指向 「-1」 还是初始化指向 「0」！）
  s->top = -1;
  
  // 擦洗内存脏数据
  for (int i = 0; i < maxSize; i ++) {
    s->data[i] = 0;
  }
  
  // 返回
  return true;
}
```

#### 封装基本操作

```c
// 顺序栈判空
bool StackEmpty(SeqStack s) {
  return (s.top == -1);
}
```

```c
// 入栈
bool Push(SeqStack * s, int data) {
  // 栈满则拒绝入栈
  if (s->top == maxSize - 1) {
    return false;
  }
  
  // 入栈
  s->data[s->top + 1] = data;
  
  // 更新栈顶指针
  s->top = s->top + 1;

  return true;
}
```

```c
// 从栈顶向栈底遍历输出栈
void printStack(SeqStack s) {
  // 栈空则直接返回
  if (s.top == -1) {
    return;
  }

  for (int i = s.top; i >= 0; i --) {
    printf("%d ", s.data[i]);
  }
  printf("\n");
  return;
}
```

```c
// 出栈
bool Pop(SeqStack * s, int * res) {
  // 栈空，则拒绝出栈
  if (s->top == -1) {
		return false;
  }
  
  // 出栈是一种逻辑上的操作，实际数据还残留在内存中
  (*res) = s->data[s->top];
  s->top = s->top - 1;
  return true;
}
```

```c
// 读栈顶
bool GetTop(SeqStack s, int * res) {
  // 栈空，拒绝读栈顶
  if (s.top == -1) {
    return false;
  }

  (*res) = s.data[s.top];
  return true;
}
```
