## 表达式求值问题

> 注意：本节（左操作数、右操作数、运算符优先级相等则左优先原则、运算符优先级相等则右优先原则）都是为了便于理解而`杜撰的概念，考试中不建议使用`！

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211014151832426.png"></img>

> 注意：无论何种表达式，都必须`先算乘除，后算加减，有括号则先算括号里面`！

#### 回顾我们最熟悉的算术表达式（中缀表达式）

> ((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1))

- 由 3 部分组成：
  - 1. `操作数`
  - 2. `运算符`
  - 3. `界限符`
- 「界限符」明确了各个运算符生效的顺序；如果去掉「界限符」，运算符生效的顺序就会发生改变；`所以，对于中缀表达式而言，必须合理设置「界限符」`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211014082641740.png"></img>

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211014093946572.png"></img>

#### 波兰数学家提出了 2 种方法，可以不用界限符，也能无歧义地说明运算顺序

- 方法一：`前缀表达式`，也称波兰表达式，Polish notation
- 方法二：`后缀表达式`，也称逆波兰表达式，Reverse Polish notation

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211014100246310.png"></img>

```
中缀表达式：a + b - c * d => 后缀表达式：ab+cd*-
						=> 前缀表达式：-+ab*cd
```

#### 中缀转后缀

##### 手算

- 中缀转后缀的方法步骤如下：

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211030092228096.png'></img>

- 理论上来说，由于中缀表达式中各个运算符的生效顺序可能并不唯一，因此对应的后缀表达式也可能不唯一

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/multi-notation.png"></img>

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211030092158501.png'></img>

##### 机算

- `但算法应具有确定性`，即同样的输入必须得到同样的输出
  - 所以我们规定采用所谓`运算符优先级相等，则左优先`的原则 => 即`只要左边的运算符能先计算，就优先算左边的`
- 为什么是`左优先`呢？
  - 因为经尝试，如果采用这样的原则，得到的输出有`先生效的运算符会先出现`的特点；否则运算符的出现顺序杂乱无章
- 无论人为规定怎样的原则，`操作数之间的先后顺序都是不变的`

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211030093240402.png'></img>

##### 代码实现

- 输入：

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211028211814927.png'></img>

- 输出：

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211028211728140.png'></img>


    /**
     * 思路：结合了王道和天勤的相关视频教程
     *
     * 后出现的操作符先能生效！=> LIFO 栈的特点！
     *
     * 注意：顺序栈都应考虑是否会栈溢出！
     */
    
    首先初始化一个栈（用于存放「左括号」 & 「暂时不能确定生效顺序的运算符」）
    
    从左到右扫描中缀表达式
    
    1. 遇到左括号，则「入栈」（起到了等着和右括号匹配 & 界限符的作用），`continue`
    
    2. 遇到操作数，则输出到结果表达式，`continue`
    
    3. 遇到运算符
         若栈空，则无法确定该运算符是否能生效，故将运算符「入栈」，`continue`
         栈不空
           若栈顶是左括号，则无法确定该运算符是否能生效，故将运算符「入栈」，`continue`
           否则（栈顶是运算符）
             若栈顶运算符的优先级小于当前运算符的优先级，则无法确定该运算符是否可以生效（因为当前运算符右侧可能出现左括号），故将运算符入栈，`continue`
             若栈顶运算符的优先级大于等于当前运算符的优先级，则栈顶运算符可以生效了，出栈一次，写入结果表达式；然后拿着当前运算符回到步骤 `3`
    
    4. 遇到右括号，则一直出栈
         出栈的是运算符则输出到结果表达式
         否则（出栈的是左括号），将左括号丢弃，停止出栈操作，`continue`
    
    扫描结束后，若栈不空，则依次出栈，输出到结果表达式

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211029121915359.png'></img>

代码实现：https://github.com/Brannua/ds_algorithm/blob/master/algorithms/normal-2-reverse-polish-notation.c

#### 计算后缀表达式

##### 手算

- 当我们采用所谓`运算符优先级相等，则左优先`的原则，将中缀表达式转换为后缀表达式后，`手算`后缀表达式的方法为：
- `从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，生成一个新的操作数，注意两个操作数的左右顺序！`（后出现的操作数先被运算！ => LIFO 栈的特点！）

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211014154008083.png"></img>

##### 机算

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211014110434875.png"></img>

##### 代码实现

- 输入：

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211028211728140.png'></img>

- 输出应为下面算式的结果：5

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211028211814927.png'></img>

代码实现：https://github.com/Brannua/ds_algorithm/blob/master/algorithms/count-reverse-polish-notation.c

#### 中缀转前缀 & 计算前缀表达式

> 无论手算机算，都和中缀转后缀道理相同，只不过现象和操作都是反着来
>
> 为了保证算法的确定性，且让运算符的出现次序`从右到左`恰好是运算符的生效顺序，规定所谓`优先级相等，则右优先`的原则
>
> 机算也应注意出栈时左右操作数的顺序~

...

#### 计算中缀表达式

> 等价于：转化为后缀表达式 + 计算后缀表达式
>
> 等价于：转化为前缀表达式 + 计算前缀表达式

<img src='https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211029232440571.png'></img>
