#### 什么是递归

> 从代码形式上来看，一个函数在运行时调用了自己，就叫递归

![image-20220128181118685](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220128181118685.png)

> 举个例子：比如要实现一个计算前 n 项和的函数（输入一个正整数 n，将 0～n 的整数累加的结果进行输出）

```c
int cumulative(int n) {
  if (n == 0) {
    return 0;
  }
  return n + cumulative(n - 1);
}
```

> 虽然上面这个例子的 if 判断条件并不严谨，代码健壮性并不够，但对于展现递归写法的样子，它简洁明了

#### 什么类型的问题适合用递归

> 若初始问题可以被转换为「类型相同」但「数据规模更小」的问题，则适合用递归来处理
>
> 注：本文将递归写法写出的函数，简称为：递归函数

#### 递归背后的执行逻辑

> 回顾：
>
> 系统会为运行中的程序开辟一个栈，用于存放各个函数在被调用执行过程中所需保存的信息，这个栈叫「函数调用栈」

- 递归函数自己调用自己当然属于函数调用，所以递归函数在执行过程中也会用到函数调用栈，也称之为「递归工作栈」

- 显然，每当递归函数被调用一次，当前调用所需保存的信息就会被压入递归工作栈

- 所以，**随着递归函数自调用次数的增加，递归算法的空间复杂度就会升高**

- 由于计算机的内存资源有限，所以递归工作栈的容量也有限，所以递归函数自调用的次数不能太多，否则一旦递归工作栈满，递归函数继续自调用，就会导致「栈溢出」，程序就会崩溃

- 显然，如果一个递归函数被错误地写成了「只递不归」的形式（比如将上面例子中的 if 判断去掉，写成如下形式），那么一旦运行该递归函数，就必然会导致栈溢出，进而程序崩溃

```c
int cumulative(int n) {
  return n + cumulative(n - 1);
}
```

- 多说一句，如果你使用 Python 语言进行编码，那么你就可以对递归函数自调用次数的上限进行设置，这可以在一定程度上避免栈溢出，确保程序的稳定运行

- 对于一个设计合理且编写正确的递归函数来说，当递归函数开始执行最后一次自调用，相对应的数据同样会被压入递归工作栈，我们说这是最后一层递归

- 对于开头的例子，显然，最后一层递归满足`n == 0`，当递归函数继续执行，就会执行`return 0;`，而不会再执行自调用的代码

- 于是，最后一层递归执行结束，与普通函数执行结束便会返回主调函数的执行上下文一样，最后一层递归会根据栈顶元素中保存的返回地址返回到上一层递归，然后递归工作栈执行一次出栈操作（删除栈顶元素）

- 然后上一层递归继续执行，执行过程同理

- 循环往复，直到递归工作栈的栈底元素出栈，递归函数便完全执行结束

#### 再来道题：计算正整数的阶乘

![image-20220128233005650](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220128233005650.png)

```c
int factorial(int n) {
  if (n == 0 || n == 1) {
    return n;
  }
  return n * factorial(n - 1);
}
```

![image-20220128232914134](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220128232914134.png)

#### 将递归算法改造为非递归算法

方向一：开发者使用自己定义的一个栈，用和递归算法相同的思想，将递归算法改造为非递归算法

方向二：不使用递归工作栈的思想，寻找非递归的解法

---

#### 递归算法执行效率低的原因二

> **递归算法的执行过程有可能包含很多重复计算**
>
> 以递归思路求解斐波纳契数列为例

```c
int Fib(int n) {
  if (n == 0 || n == 1) {
    return n;
  }  
  return Fib(n - 1) + Fib(n - 2);
}
```

![image-20220128234327730](https://aliyun-oss-lpj.oss-cn-qingdao.aliyuncs.com/images/by-picgo/image-20220128234327730.png)

> 优化思路：使用数据缓存，核心代码如下

```c
int Fibonacci(int Idx) {
  if (Idx == 0 || Idx == 1) {
    return 1;
  }

  int before_one_Idx = Idx - 1,
      before_two_Idx = Idx - 2;

  // 没计算过就计算一次然后立刻缓存起来
  if (_cache[before_one_Idx] == 0) {
    _cache[before_one_Idx] = Fibonacci(before_one_Idx);
  }
  if (_cache[before_two_Idx] == 0) {
    _cache[before_two_Idx] = Fibonacci(before_two_Idx);
  }

  // 直接读取缓存即可
  return _cache[before_one_Idx] + _cache[before_two_Idx];
}
```

#### 递归算法的唯一优点

> 算法思路好想，写出的代码简洁
