

> 若原始问题可被转换为 「属性相同」 但 「规模较小」 的问题，则适合用递归来处理
>
> 为递归函数创建的函数调用栈被称为 「递归工作栈」
>
> 以计算正整数的阶乘为例

- 和普通函数调用相同
  - 每进入一层递归，就将递归调用所需信息压入栈顶（`太多层的递归可能会导致 「栈溢出」！`，因为内存资源有限，系统给我们开辟的函数调用栈的容量肯定有上限）
  - 每退出一层递归，就从栈顶弹出相应信息
- 再次理解 => `递归算法的 「空间复杂度」 会随着递归层数的变多而变高`

![image-20211013174901442](https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013174901442.png)

#### 将递归算法改造为非递归算法

- 类比 IDE 中观察到的下图
- 我们可以`自定义一个栈，用和递归算法相同的思想，将递归算法改造为非递归算法`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013175528281.png"></img>

#### 用 「函数调用栈」 理解递归实现的斐波那契数列

```c
/**
 * 斐波那契数列（递归实现）
 */

#include <stdio.h>

int Fib(int n) {

  if (n == 0 || n == 1) {
    return n;
  }  

  return Fib(n - 1) + Fib(n - 2);

}

int main() {
  printf("%d\n", Fib(4));
  return 0;
}
```

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013222421559.png"></img>

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013223037401.png"></img>

#### 递归的缺点

1. 空间复杂度会随着递归层数的变多而变高，且可能导致 「栈溢出」

2. 效率低，可能包含很多重复计算
