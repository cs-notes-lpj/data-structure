#### 从普通函数式程序的分析入手

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013170556743.png"></img>

- 函数的执行顺序：main -> func1 -> func2

- 函数执行结束的顺序：func2 -> func1 -> main

> 不难看出：越是靠后执行的函数，越是更先执行结束 ==> 后进先出(LIFO) ==> 栈

---

#### 函数调用栈

- 其实，对于任何一段代码/一个程序

- 当运行的时候，系统都会给我们开辟一个栈，用来存放各个函数在执行过程中需要保存的信息，这个栈被称为「函数调用栈」

- 函数调用栈用于保存以下信息

1. 实参

2. 局部变量

3. 当前函数执行结束后的返回地址

---

> 对于本节开头的图，系统为我们开辟的函数调用栈大致如下

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013171656427.png"></img>

- func2 执行结束后，会根据 #2 这个地址返回到 fun1 中继续执行，并且函数调用栈出栈（即：func2 在函数调用栈中保存的信息被删除，所占内存空间被释放回收）

- func1 执行结束后同理

- main 执行结束后同理

---

#### 现在，我们使用 IDE 进行 DEBUG 时，就能轻易看懂函数调用栈的相关信息，如下

> 下图并没有体现函数调用结束后的返回地址

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013172514321.png"></img>

---

#### 递归工作栈

> 若原始问题可被转换为 「属性相同」 但 「规模较小」 的问题，则适合用递归来处理
>
> 为递归函数创建的函数调用栈被称为 「递归工作栈」
>
> 以计算正整数的阶乘为例

- 和普通函数调用相同
  - 每进入一层递归，就将递归调用所需信息压入栈顶（`太多层的递归可能会导致 「栈溢出」！`，因为内存资源有限，系统给我们开辟的函数调用栈的容量肯定有上限）
  - 每退出一层递归，就从栈顶弹出相应信息
- 再次理解 => `递归算法的 「空间复杂度」 会随着递归层数的变多而变高`

![image-20211013174901442](https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013174901442.png)

#### 将递归算法改造为非递归算法

- 类比 IDE 中观察到的下图
- 我们可以`自定义一个栈，用和递归算法相同的思想，将递归算法改造为非递归算法`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013175528281.png"></img>

#### 用 「函数调用栈」 理解递归实现的斐波那契数列

```c
/**
 * 斐波那契数列（递归实现）
 */

#include <stdio.h>

int Fib(int n) {

  if (n == 0 || n == 1) {
    return n;
  }  

  return Fib(n - 1) + Fib(n - 2);

}

int main() {
  int x = Fib(4);
  printf("%d\n", x);
 return 0;
}
```

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013222421559.png"></img>

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013223037401.png"></img>

#### 递归算法的缺点

1. 空间复杂度会随着递归层数的变多而变高，且可能导致 「栈溢出」

2. 效率低，可能包含很多重复计算
