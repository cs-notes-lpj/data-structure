#### 一般的函数调用过程

- 函数调用顺序依次为：main、func1、func2
- 函数执行结束的顺序依次为：func2、func1、main

- 可以看出，`最后被调用的函数最先执行结束（LIFO）` => 即：`普通函数的调用过程和栈的后进先出异曲同工`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013170556743.png"></img>

#### 什么是 「函数调用栈」

> 事实上，运行任何一段代码、任何一个程序
>
> 系统都会给我们开辟一个 「函数调用栈」，用来保存各个函数在被调用过程中所必须保存的一些信息

- 函数调用栈保存下列信息
  - 1. 实参
  - 2. 局部变量
  - 3. 调用返回地址
  
- 对于上图的函数调用过程，开辟的函数调用栈大致如下
  - func2 执行结束后，就会根据 #2 这个调用返回地址，返回到 func1 中继续执行；同时函数调用栈出栈，即 func2 在函数调用栈中保存的信息被删除，所占内存空间被释放回收
  - func1 执行结束后同理
  - main 执行结束后同理

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013171656427.png"></img>

#### 现在，我们使用 IDE 进行 Debug 时，就能轻易看懂函数调用栈的相关信息，如下

> 注意到函数调用栈中，main 函数下面还有东西，但这并不需要我们普通程序员关心
>
> 其次，下图并没有体现函数调用结束后的返回地址

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013172514321.png"></img>

#### 什么是 「递归工作栈」

> 若原始问题可被转换为 「属性相同」 但 「规模较小」 的问题，则适合用递归来处理
>
> 为递归函数创建的函数调用栈被称为 「递归工作栈」
>
> 以计算正整数的阶乘为例

- 和普通函数调用相同
  - 每进入一层递归，就将递归调用所需信息压入栈顶（`太多层的递归可能会导致 「栈溢出」！`，因为内存资源有限，系统给我们开辟的函数调用栈的容量肯定有上限）
  - 每退出一层递归，就从栈顶弹出相应信息
- 再次理解 => `递归算法的 「空间复杂度」 会随着递归层数的变多而变高`

![image-20211013174901442](https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013174901442.png)

#### 如何将递归算法改造为非递归算法

- 类比 IDE 中观察到的下图
- 我们可以`自定义一个栈，用和递归算法相同的思想，将递归算法改造为非递归算法`

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013175528281.png"></img>

#### 用 「函数调用栈」 理解递归实现的斐波那契数列

```c
/**
 * 斐波那契数列（递归实现）
 */

#include <stdio.h>

int Fib(int n) {

  if (n == 0 || n == 1) {
    return n;
  }  

  return Fib(n - 1) + Fib(n - 2);

}

int main() {
  int x = Fib(4);
  printf("%d\n", x);
 return 0;
}
```

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013222421559.png"></img>

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211013223037401.png"></img>

#### 总结递归算法的缺点

1. 空间复杂度会随着递归层数的变多而变高，且可能导致 「栈溢出」
2. 效率低，可能包含很多重复计算
