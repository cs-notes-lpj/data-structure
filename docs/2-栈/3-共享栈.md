> 所有的新方案都是为了解决老方案的缺点

#### 回顾顺序栈的缺点

- `栈的大小无法改变` <= 静态数组存储数据元素

#### 弥补缺点的思路

1. 采用 「链式存储」 而不是顺序存储 => 下一节讲的 「链栈」

2. 刚开始就为顺序栈分配一片较大的连续内存空间

#### 第 2 种思路太浪费内存，所以 「共享栈」 被提出

> 即：让两个栈共享同一片连续的内存空间，以提高内存利用率~

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211012211920672.png"></img>

```c
// 声明一个共享栈，期望的做法是
ShStack s;
```

```c
// 代码实现
#define maxSize 10			// 定义 「共享栈容量」
typedef struct {
  ElemType data[maxSize];	// 存放 「共享栈的数据元素」
  int top0;					// 一个栈的栈顶指针
  int top1;						// 另一个栈的栈顶指针
} ShStack;
```

```c
// 我们期望这么对共享栈进行初始化
InitShStack(&s);
```

```c
// 代码实现
typedef enum { false = 0, true } bool;
// 初始化共享栈
bool InitShStack (ShStack * s) {
  s->top0 = -1;
  s->top1 = maxSize;

  // 擦洗内存脏数据
  for (int i = 0; i < maxSize; i ++) {
    s->data[i] = 0;
  }
   
  // 返回
  return true;
}
```

#### 封装基本操作

```c
// 共享栈判空
bool isEmptyShStack(ShStack s) {
  return (s.top0 == -1 && s.top1 == maxSize);
}

// 共享栈判满
bool isFullShStack(ShStack s) {
  return (s.top0 + 1 == s.top1);
}
```

```c
// 清空栈（逻辑上的操作）
bool makeEpmty(ShStack * s) {
  (*s).top0 = -1;
  (*s).top1 = maxSize;
  return true;
}

// 以「变量声明」的方式申请的内存，内存回收工作由系统负责
// 而 malloc 申请的内存属于堆内存，需开发者手动调用 free 函数进行内存释放回收（即：malloc 和 free 必须成对使用！）
```

#### 小结

<img src="https://gitee.com/pj-l/imgs-1/raw/master/screenShot/image-20211012173615247.png"></img>
